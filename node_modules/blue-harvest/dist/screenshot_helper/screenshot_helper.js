"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const os = require("os");
const path = require("path");
const protractor_1 = require("protractor");
let mask_fn = require('./mask').MASK_FN;
// Require looks-same casted with shim interface LooksSame typing.
let looksSame = require('looks-same');
/**
 * Compare a screenshot to a reference, or "golden" image.
 * Returns a Promise that resolves to whether or not the
 * screenshot is a match. If the UPDATE_SCREENSHOTS environment
 * variable is set, the promise resolves to true and the
 * golden image is updated.
 *

 * @param data - The screenshot image data.
 * @param golden - The path to the golden image to compare to.
 * @param outputFolder - The destination path for saving the diff. if it is not provided, the difference image will not be

 *   saved.
 */
function compareScreenshot(data, golden, outputFolder = undefined) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const tempFolder = createTempFolder();
            const screenshotPath = yield writeScreenshot(tempFolder, data);
            // check if goldens need to be updated
            const update = process.env['UPDATE_GOLDENS'] === '1' || process.env['UPDATE_GOLDENS'] === 'true';
            if (update) {
                fs.writeFileSync(golden, fs.readFileSync(screenshotPath));
                resolve('Reference image ' + golden + ' was successfully updated.');
                return;
            }
            const goldenName = path.basename(golden);
            looksSame(screenshotPath, golden, {
                strict: false,
                tolerance: 2.5,
            }, (error, equal) => __awaiter(this, void 0, void 0, function* () {
                if (error) {
                    reject("There has been an error. Error: " + error);
                    return;
                }
                if (!equal) {
                    if (outputFolder) {
                        const diffPath = path.join(outputFolder, `diff-${goldenName}`);
                        looksSame.createDiff({
                            reference: golden,
                            current: screenshotPath,
                            diff: diffPath,
                            highlightColor: '#ff00ff',
                        }, (err) => {
                            if (err) {
                                reject('An error occurred while saving the diff image: ' + err);
                                return;
                            }
                            reject(`Screenshots do not match for ${golden}. Difference picture is saved as ${diffPath}.`);
                        });
                    }
                    else {
                        reject(`Screenshots do not match for ${golden}.`);
                    }
                }
                else {
                    resolve('The test passed. ');
                }
            }));
        }));
    });
}
exports.compareScreenshot = compareScreenshot;
function createTempFolder() {
    return fs.mkdtempSync(`${os.tmpdir()}${path.sep}`);
}
/**
 *  Write a screenshot to disk in a new temporary path.
 */
function writeScreenshot(folder, data) {
    return __awaiter(this, void 0, void 0, function* () {
        let screenshotFile = path.join(folder, 'new.png');
        fs.writeFileSync(screenshotFile, data, 'base64');
        return screenshotFile;
    });
}
function addMask(el, color, zIndex = 10000, xOffset = 0, yOffset = 0, sizeMultiplier = 1.0) {
    return __awaiter(this, void 0, void 0, function* () {
        let size = yield el.getSize();
        let location = yield el.getLocation();
        const mask = yield protractor_1.browser.executeScript(mask_fn, location.x + xOffset, location.y + yOffset, size.width * sizeMultiplier, size.height * sizeMultiplier, color, zIndex);
        return mask;
    });
}
exports.addMask = addMask;
function removeMask(mask) {
    return __awaiter(this, void 0, void 0, function* () {
        yield protractor_1.browser.executeScript("arguments[0].parentNode.removeChild(arguments[0])", mask);
    });
}
exports.removeMask = removeMask;
//# sourceMappingURL=screenshot_helper.js.map